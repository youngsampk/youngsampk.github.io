<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="박영삼">
<meta name="dcterms.date" content="2023-03-24">

<title>소득분배, 3년간 개선하다 악화한 까닭 – Labor &amp; Society</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Labor &amp; Society</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../research/index.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://facebook.com"> <i class="bi bi-facebook" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="http://yspark1968.blogspot.com/"> 
<span class="menu-text">Blogger</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">소득분배, 3년간 개선하다 악화한 까닭</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">소득분배</div>
                <div class="quarto-category">가계금융복지조사</div>
                <div class="quarto-category">소득불평등</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>박영삼 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 24, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="박영삼의-통계로-보는-노동" class="level4">
<h4 class="anchored" data-anchor-id="박영삼의-통계로-보는-노동">박영삼의 통계로 보는 노동</h4>
</section>
<section id="소득분배-3년간-개선하다-악화한-까닭" class="level2">
<h2 class="anchored" data-anchor-id="소득분배-3년간-개선하다-악화한-까닭">소득분배, 3년간 개선하다 악화한 까닭</h2>
<section id="가계금융복지-원자료-분석-결과-조세공적이전소득-고소득층에-유리하게-작용" class="level4">
<h4 class="anchored" data-anchor-id="가계금융복지-원자료-분석-결과-조세공적이전소득-고소득층에-유리하게-작용">가계금융복지 원자료 분석 결과 … 조세·공적이전소득 고소득층에 유리하게 작용</h4>
<p>지난달 중순 가계금융복지조사 마이크로데이터가 공개됐다. 우리나라 전체 가구의 소득과 자산, 부채에 관한 정보를 모두 담고 있는 가장 최근의 공식 통계다. 소득은 코로나 위기 2년차였던 2021년 말 기준 자료이고, 자산과 부채는 지난해 3월 기준이다. 주요 집계표는 지난해 12월에 통계청의 보도자료와 포털사이트(KOSIS)를 통해 공개됐지만 원자료는 3개월이 더 지난 뒤에야 공개된 것이다.<br>
<br>
이와 별도로 분기별 가계동향조사가 있고 지난달 비슷한 시기에 2022년 4분기 조사결과와 원자료가 거의 비슷한 시기에 공개됐다. 하지만 가계동향조사는 자산·부채에 관한 내용은 담고 있지 않다. 가계부조사 방식을 택하고 있기 때문에 고소득층에 대한 접근이 제약되는 문제가 있다. 또한 속보치로서 갖는 장점은 있지만 분기 소득통계만 확인할 수 있어서 연간에 걸친 소득과 지출, 비용처리를 모두 고려한 연간소득을 알기 어렵다는 단점도 있다. 따라서 국세청의 종합소득 신고내역과 금융기관 등이 보유한 행정자료를 통해 대폭 보완되는 가계금융복지조사를 통해 기존에 잘 다뤄지지 않은 가구소득 상태를 다시 살펴보기로 한다.<br>
</p>
<p><strong>시장소득 50대 중반 이후 하락…공적이전소득 역할 미흡</strong></p>
<p>일반적으로 가구의 평균 소득 수준과 자산 축적은 생애주기에 따라 달라진다. 근로소득이 중심이 되는 시장소득은 가구주의 연령이 50~54세에 정점(7천822만원)에 도달한다. 35~39세 시기에 여성의 경력단절로 시장소득 상승이 주춤하는 모습을 보이기도 한다.&lt;본지 2023년 3월10일자 10면 ‘여성, 39세에 맞는 잔인한 일자리 퇴출’ 기사 참조&gt; 반면에 순자산은 저축과 자산형성, 부채상환을 통해 은퇴연령 전후까지 완만히 상승하는 경향을 보이다가 은퇴 이후에 시장소득과 함께 빠르게 감소한다. 이러한 시기에 연금급여와 정부보조금 등 공적이전소득이 시장소득 감소를 보충해 줘야 하는데, 우리나라는 이런 장치가 매우 취약한 편이다. 평균적으로 7천만원 수준이던 59세 연령의 가구 평균시장소득이 70세에 2천500만원 수준으로 약 4천500만원 감소하는 동안, 공적이전 소득은 같은 기간 380만원에서 1천200만원으로 약 800만원 증가에 그쳐 시장소득과 처분가능소득이 낮은 수준에서 하향 분포를 보인다.<br>
</p>
<p><img src="news_01.jpg" class="img-fluid quarto-figure quarto-figure-center" width="600" alt="Caption"><br>
이런 이유 때문에 노인 가구의 부동산을 중심으로 한 자산에 주목하게 된다. 가계금융복지조사의 평균치 자료만 보면 65~69세 가구주는 평균 5억4천968만원 수준의 순자산을 보유한 것으로 나타난다.<br>
<br>
하지만 이러한 수치들은 모두 각 연령대의 ‘일반적 평균’이라는 함정을 안고 있다. 소득과 자산의 평균치는 실제 가구들의 상태보다 과대 평가된 수치들이다.<br>
<br>
우리나라 전체 가구의 평균소득은 2021년 말 기준 6천413만원이며 평균 순자산은 4억5천602만원에 이른다. 하지만 중위값으로 보면 소득은 5천22만원 수준이고 순자산은 2억4천662만원으로 떨어진다. 중위소득은 평균소득의 78% 수준에 그치고 순자산 중위값은 평균 순자산액의 54% 수준에 불과하다. 고소득, 고자산가들의 소득과 부가 전체의 평균을 과장하고 있는 셈이다. 자산은 일부 가구에 몰려 있고 자산이 거의 없는 가구 비중이 높다. 1억원에 미달하는 가구가 전체의 30%를 넘는다. 순자산이 마이너스인 가구도 많다. 우리나라 가구 순자산 평균에 해당하는 4억5천600만원을 보유한 가구는 순자산 분위로 따지면 상위 31%에 위치한다.<br>
<br>
<strong>자산 많은 저소득 노인가구? 실제로는 드물어</strong><br>
<br>
자산과 소득의 분위를 교차해서 분포를 살펴보면 이러한 사실이 보다 명확해진다. 아래 그림을 보면 대부분 가구들은 소득과 자산이 동조하는 관계임을 알 수 있다. 소득이 높으면 자산도 많고(고소득=고자산), 소득이 낮으면 자산도 적다. 소득이 상위 20%에 속하면서 순자산도 상위 20%에 속하는 ’고소득-고자산’ 가구가 220만가구로 전체의 10.2%를 차지한다. 순자산 상위 20% 가구의 절반 이상이 소득으로도 상위 20%에 속하는 셈이다. 한편 소득이 하위 20%에 속하고 순자산도 하위 20%에 속하는 저소득-저자산 가구가 108만가구로 역시 9.7%를 차지한다. 자산이 가장 적은 가구의 대부분은 소득이 적은 가구라는 뜻이다. 반면 소득이 하위 20%에 속하면서 순자산만 상위 20%에 해당하는 ‘저소득-고자산’ 가구는 모두 합쳐도 18만가구로 전체 2천150만가구의 0.9%에 불과하다. 특히 66세 이상 가구의 경우 소득이 없어도 자산을 꽤 보유한 가구가 많은 것으로 얘기되고 있는데 사실은 그렇지 않다.<br>
<br>
노인가구 534만가구 중 순자산 상위 20%에 속하는 가구는 12만가구로 전체 노인가구의 2.3%에 불과하다. 순자산 상위 40%까지 포함하더라도 그 비율은 5%를 넘지 않는다. 노인 가구일수록 저소득-저자산 가구 비중이 압도적으로 높다. 순자산이 많은 가구는 소득이 많은 중장년 이하 가구들이 주로 해당된다. 이런 점에서 노인가구 중 상당수가 소득은 낮지만 상대적으로 자산이 많을 것이라는 예상은 실제 사실과 부합하지 않는다. 자산과세를 강화하는 것이 소득 없이 자산에만 의존하는 노인가구를 어렵게 할 것이라는 주장도 진실과는 거리가 있다.<br>
</p>
<p><img src="news_02.jpg" class="img-fluid quarto-figure quarto-figure-center" width="600" alt="Caption"><br>
</p>
<p><strong>OECD 최하위 소득분배 개선 효과 더 떨어질 수도</strong><br>
<strong>저소득 빈곤층 위한 정부 역할 중요</strong><br>
</p>
<p><br>
오히려 2021년 가계금융복지조사에서 나타나는 소득분배 악화 흐름은 조세와 공적이전을 담당하는 정부의 역할이 중요하다는 사실을 다시 한번 확인시켜 주고 있다.<br>
<br>
경제협력개발기구(OECD)가 제공하는 가장 최근의 국가별 소득불평등 지표를 보면 우리나라의 2020년 기준 시장소득 지니계수는 OECD 평균보다 낮지만 조세와 공적이전소득을 포함한 세후 지니계수는 0.331로 OECD 평균보다 높다. 시장소득과 처분가능소득의 지니계수 차이가 크지 않다는 것은 조세와 복지지출이 소득재분배 기능을 제대로 하지 못하고 있다는 것을 의미한다. OECD 통계에서 우리나라의 조세와 공적이전 불평등 개선 효과는 18%에 불과해 37개 회원국 중 33위로 꼴찌에서 다섯 번째다. 근로연령대(15~64)의 불평등 개선 효과는 15%(세전 0.365·세후 0.312)로 34위이며, 은퇴연령대의 개선 효과도 31%(세전 0.554·세후 0.376)로 35개국 중 31위다. 아직 OECD 데이터에 수록되지는 않았지만 2021년 가계금융복지조사의 지니계수(시장소득 0.405, 처분가능소득 0.333)를 업데이트한다면 2020년에 비해 처분가능소득 지표가 더 악화하고 조세와 공적이전에 의한 개선효과는 더 후퇴할 것으로 예상된다.<br>
</p>
<p><img src="news_03.jpg" class="img-fluid quarto-figure quarto-figure-center" width="600" alt="Caption"><br>
2017년 이후 2020년까지는 3년 연속 계속 개선 양상을 보이던 소득분배지표들이 2021년에 들어 대부분 악화한 것은 조세와 공적이전소득이 고소득층에 유리한 방향으로 변화했기 때문으로 풀이된다.<br>
<br>
가계금융복지조사 원자료를 가지고 경상조세를 시장소득 합계액으로 나눈 비율을 산출해 봤다. 그 결과 1억원 이상 소득구간의 경우 2018년에는 세율이 11.3%로 증가했다가 2021년에는 10.9% 수준으로 하락한 반면, 5천만원 이하 소득구간에 대한 세율은 증가 추이를 보였다. 이와 함께 공적이전소득이 하위 20% 1분위 가구의 소득에서 차지하는 비중은 계속 하락했다. 반면 상위 20%인 5분위의 공적이전소득 점유비중은 15.9%에서 17.6%까지 증가한 것으로 나타난다.<br>
<br>
문재인 정부에서 최고소득세율 구간을 신설한 뒤에는 소득세에 관해서는 추가적인 증세나 과세강화 방안이 나오지 않았고, 코로나 위기 이후 다양한 형태의 정부지원과 공적연금 수급가구 확대가 소득이 많은 고소득가구의 수혜로 나타나고 있기 때문이다. 저소득 계층을 위한 재정지원과 고소득층에 대한 과세 강화가 다시 필요한 이유다.<br>
</p>
<p><img src="news_04.jpg" class="img-fluid quarto-figure quarto-figure-center" width="600" alt="Caption"> <img src="news_05.jpg" class="img-fluid quarto-figure quarto-figure-center" width="600" alt="Caption"></p>
<p>박영삼 고려대 노동문제연구소 노동데이터센터장 (<a href="youngsampk@gmail.com">youngsampk@gmail.com</a>)<br>
출처 : <a href="http://www.labortoday.co.kr/news/articleView.html?idxno=214152">매일노동뉴스(http://www.labortoday.co.kr)</a></p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>